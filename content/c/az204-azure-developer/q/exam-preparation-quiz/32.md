---
title: "Fix Non-Deterministic Durable Function Workflow"
type: "question"
layout: "single"
answers:
    - id: "answer1"
      title: "Ensure that all Orchestrator code is deterministic"
      correct: true
      explain: "Orchestrator functions are replayed multiple times during execution, and must produce the same result each replay. Non-deterministic code like DateTime.Now, random numbers, or calling non-deterministic APIs will produce different results on replay when multiple function instances run. Making all orchestrator code deterministic ensures consistent behavior regardless of instance count or replay frequency."
    - id: "answer2"
      title: "Implement the monitor pattern within the workflow"
      correct: false
      explain: "The monitor pattern is for scenarios that require flexible, recurring processes in a workflow (like polling). While useful for specific use cases, it doesn't address the root cause of non-deterministic behavior—it's a workflow pattern, not a solution for ensuring code produces consistent results across replays."
    - id: "answer3"
      title: "Read all state data from the durable function context"
      correct: false
      explain: "While reading from the durable function context is good practice for accessing orchestration state, it alone doesn't prevent non-deterministic behavior. If the orchestrator code itself contains non-deterministic operations (like DateTime.Now or random values), the context won't solve inconsistent results across replays."
    - id: "answer4"
      title: "Configure the Azure Durable Function to run on an App Service Plan with one instance"
      correct: false
      explain: "Limiting to one instance might mask the symptoms temporarily, but it doesn't fix the underlying problem and defeats the purpose of using scalable serverless architecture. Orchestrator functions are designed to be replayed, and non-deterministic code will still cause issues even with a single instance during replay operations."
link: "https://learn.microsoft.com/en-us/azure/azure-functions/durable/durable-functions-code-constraints"
more: "Learn more about Orchestrator Code Constraints"
learn: "Durable Functions Constraints"
---

You work as a Serverless Workflow Developer for MDFT Pro, a well-known training agency that delivers certification courses to students worldwide. Claire, the Backend Architecture Lead, has tasked you with developing a complex student enrollment workflow using Azure Durable Functions. The workflow orchestrates multiple steps including validating student credentials, checking course prerequisites, processing payments, sending confirmation emails, and provisioning access to course materials. During testing with different load patterns, you observe that the workflow produces inconsistent results—sometimes students receive duplicate emails, access provisioning fails intermittently, and payment confirmations show different timestamps. The inconsistencies only occur when multiple instances of the Azure Function are running simultaneously under load, but work correctly with a single instance. The workflow must produce reliable, consistent results regardless of how many function instances are processing enrollments concurrently.

What should you do to resolve this issue?
